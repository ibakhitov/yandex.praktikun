1. Наглядность и лаконичность
Вы будете управлять данными в таблицах и получите новые инструменты для их анализа.
Чему вы научитесь
Сортировать данные в таблицах, добавлять новые столбцы и выбирать интересные строки.
Сколько времени это займёт
2 часа: 11 уроков примерно по 12 минут.
Постановка задачи
Продолжим исследовать употребление эмодзи на разных платформах и установим, какие чувства чаще всего выражают подобными символами. Проверим нашу рабочую гипотезу о преобладании эмодзи, поднимающих настроение.

########################################################################################################################
2. Вывод на одной строке
Мы будем печатать много, поэтому давайте расширим арсенал средств вывода на экран. Вы помните, что функция print() заканчивает печать переносом строки?
print('Анализ')
print('эмодзи')
Анализ
эмодзи
Этого можно избежать, указав ключ end (англ. end, «конец»). Он сообщает, что печать нужно закончить не переносом (как это происходит по умолчанию), а, к примеру, пустой строкой:
print('Анализ', end='')
print('эмодзи')
Анализэмодзи
Чтобы слова разделял пробел, его нужно добавить после первого слова либо перед вторым:
print('Анализ ', end='')
print('эмодзи')
Анализ эмодзи
end — это именованный аргумент. Для него нужно указать не только значение, но и имя. Именованные аргументы придуманы для функций, у которых бывает много разных аргументов и опций, и без имён можно запутаться, что к чему относится. Обратите внимание, что вокруг знака = для именованных аргументов пробелы не ставят.

# 2 - Вывод на одной строке

Мы будем печатать много, поэтому давайте расширим арсенал средств вывода на экран. Вы помните, что функция print() заканчивает печать переносом строки?
print('Анализ')
print('эмодзи')
Анализ
эмодзи
Этого можно избежать, указав ключ end (англ. end, «конец»). Он сообщает, что печать нужно закончить не переносом (как это происходит по умолчанию), а, к примеру, пустой строкой:
print('Анализ', end='')
print('эмодзи')
Анализэмодзи
Чтобы слова разделял пробел, его нужно добавить после первого слова либо перед вторым:
print('Анализ ', end='')
print('эмодзи')
Анализ эмодзи
end — это именованный аргумент. Для него нужно указать не только значение, но и имя. Именованные аргументы придуманы для функций, у которых бывает много разных аргументов и опций, и без имён можно запутаться, что к чему относится. Обратите внимание, что вокруг знака = для именованных аргументов пробелы не ставят.

ЗАДАЧА
# Названия столбцов, образующие «шапку» таблицы, хранятся в списке header. Выведите «шапку» на экран в таком виде:
#
# Скопировать код
# | Название | EmojiXpress, млн | Instagram, млн | Твиттер, млн |
#
# Используйте для этого цикл и функцию print() без переноса строки

# SOLUTION

header = [
        'Название', 'EmojiXpress, млн', 'Instagram, млн', 'Твиттер, млн'
]

# сначала напечатайте одну вертикальную черту
print('|', end='')
 

name in header:
  # поставьте пробел
    print(' ', end='')
  
  # напечатайте очередное название из "шапки"
    print(name, end='')

  # поставьте ещё один пробел и вертикальную черту
    print(' |', end='')

########################################################################################################################
3. Методы в Python
Чтобы лучше понять ситуацию на разных платформах, расставим эмодзи в порядке их встречаемости. Для этого нужно сортировать элементы выбранного столбца таблицы.
Сначала давайте научимся сортировать обычные списки чисел. Для этого в Python существует функция sort():
emojixpress = [
    2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0,
    4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333
]

emojixpress.sort()

print(emojixpress)
[0.0333, 1.74, 2.26, 3.31, 4.5, 4.72, 6.0, 6.81, 10.0, 15.2, 19.1, 21.7, 22.7, 23.1, 24.7, 25.6, 64.6, 87.5, 118.0, 233.0]
Обратите внимание на особый способ вызова функции sort() — она записывается через точку после списка. Это называется точечная нотация.
Функция sort() прикреплена к типу данных list и выполняет свою работу над переменной этого типа. Такие функции называются методами.
Мы уже имели дело с одним методом — функцией format(), закреплённой за типом данных str. Обратите внимание, что все методы вызываются с точечной нотацией.

# 3 - Методы в Python

Чтобы лучше понять ситуацию на разных платформах, расставим эмодзи в порядке их встречаемости. Для этого нужно сортировать элементы выбранного столбца таблицы.
Сначала давайте научимся сортировать обычные списки чисел. Для этого в Python существует функция sort():
emojixpress = [
    2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0,
    4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333
]

emojixpress.sort()

print(emojixpress)
[0.0333, 1.74, 2.26, 3.31, 4.5, 4.72, 6.0, 6.81, 10.0, 15.2, 19.1, 21.7, 22.7, 23.1, 24.7, 25.6, 64.6, 87.5, 118.0, 233.0]
Обратите внимание на особый способ вызова функции sort() — она записывается через точку после списка. Это называется точечная нотация.
Функция sort() прикреплена к типу данных list и выполняет свою работу над переменной этого типа. Такие функции называются методами.
Мы уже имели дело с одним методом — функцией format(), закреплённой за типом данных str. Обратите внимание, что все методы вызываются с точечной нотацией.

ЗАДАЧА
# Списки строк тоже можно сортировать методом sort() — они расположатся в алфавитном порядке. Расставьте названия всех
# эмодзи по алфавиту и выведите список на экран, печатая каждый элемент с новой строки:
#
# Скопировать код
# Глаза-сердца
# Громко плачу
# Два сердца
# ...
# Широкая улыбка
#
# Список названий хранится в переменной emoji_names

# SOLUTION

emoji_names = [
    'Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 'Слёзы радости',
    'Подмигиваю', 'Счастлив', 'Глаза-сердца', 'Целую', 
    'Задумчивость', 'Равнодушие', 'Солнечные очки', 'Громко плачу', 
    'След от поцелуя', 'Два сердца', 'Сердце', 'Червы', 
    'Класс', 'Пожимаю плечами', 'Огонь', 'Переработка'
]

# вызовите метод sort() у списка emoji_names
emoji_names.sort()

for name in emoji_names:
    print(name)

########################################################################################################################
4. Булевы значения True и False. Аргументы метода sort()
По умолчанию метод sort() упорядочивает список по возрастанию. Если мы хотим сортировать по убыванию, нужно указать это именованным аргументом reverse:
emojixpress = [
    2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0,
    4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333
]

emojixpress.sort(reverse=True)

print(emojixpress)
[233.0, 118.0, 87.5, 64.6, 25.6, 24.7, 23.1, 22.7, 21.7, 19.1, 15.2, 10.0, 6.81, 6.0, 4.72, 4.5, 3.31, 2.26, 1.74, 0.0333]
Аргументу reverse присваивается значение True. Оно принадлежит к новому типу данных bool, который назван в честь Джорджа Буля (George Boole), создателя исчисления высказываний. Он придумал записывать логические утверждения символами. Для данных булевого типа возможно одно из двух значений: True либо False. Выражение reverse=True на языке Python надо понимать так: да, сортировка действительно должна быть в обратном порядке. Если мы этого не напишем, Python по умолчанию сочтёт, что reverse=False, т.е. «нет, обратного порядка не нужно».
True и False пишутся в Python с заглавной буквы — так их легче отличать от имён переменных и аргументов.

# 4 - Булевы значения True и False. Аргументы метода sort()

По умолчанию метод sort() упорядочивает список по возрастанию. Если мы хотим сортировать по убыванию, нужно указать это именованным аргументом reverse:
emojixpress = [
    2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0,
    4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333
]

emojixpress.sort(reverse=True)

print(emojixpress)
[233.0, 118.0, 87.5, 64.6, 25.6, 24.7, 23.1, 22.7, 21.7, 19.1, 15.2, 10.0, 6.81, 6.0, 4.72, 4.5, 3.31, 2.26, 1.74, 0.0333]
Аргументу reverse присваивается значение True. Оно принадлежит к новому типу данных bool, который назван в честь Джорджа Буля (George Boole), создателя исчисления высказываний. Он придумал записывать логические утверждения символами. Для данных булевого типа возможно одно из двух значений: True либо False. Выражение reverse=True на языке Python надо понимать так: да, сортировка действительно должна быть в обратном порядке. Если мы этого не напишем, Python по умолчанию сочтёт, что reverse=False, т.е. «нет, обратного порядка не нужно».
True и False пишутся в Python с заглавной буквы — так их легче отличать от имён переменных и аргументов.

ЗАДАЧА

# Напечатайте на экране список количества постов в Твиттере в порядке убывания (сначала большие значения, потом
# поменьше). Каждое значение выводите на отдельной строке

# SOLUTION

twitter = [
    87.3, 150, 0.0, 2270.0, 264.0, 565.0, 834.0, 432.0, 0.0, 478.0, 
    198.0, 654.0, 98.7, 445.0, 1080.0, 697.0, 227.0, 0.0, 150.0, 932.0
]

# вызовите метод sort() у переменной twitter с ключом reverse=True
twitter.sort(reverse=True) # допишите код вместо многоточия

for count in twitter:
    print(count)

########################################################################################################################
5. Сортировка по столбцу
Напомним, что Python хранит таблицу как список списков. Если нужно отсортировать её по определённому столбцу, его указывают именованным аргументом key. Переставим строки таблицы так, чтобы элементы столбца «EmojiXpress, млн» расположились в порядке возрастания:
 data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

data.sort(key=lambda row: row[1])

print('Название эмодзи  | EmojiXpress, млн |', end='')
print(' Instagram, млн | Твиттер, млн')
print('-------------------------------------', end='')
print('------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))
Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн
-------------------------------------------------------------------
Переработка      |             0.03 |           0.06 |       932.00
Пожимаю плечами  |             1.74 |           0.11 |         0.00
Ухмыляюсь        |             2.26 |           1.02 |        87.30
Червы            |             3.31 |           1.82 |       697.00
Огонь            |             4.50 |           2.49 |       150.00
Солнечные очки   |             4.72 |           3.93 |       198.00
Равнодушие       |             6.00 |           0.24 |       478.00
Задумчивость     |             6.81 |           0.64 |         0.00
Два сердца       |            10.00 |           5.69 |       445.00
Подмигиваю       |            15.20 |           2.36 |       264.00
Сияю от радости  |            19.10 |           1.69 |       150.00
След от поцелуя  |            21.70 |           2.87 |        98.70
Счастлив         |            22.70 |           4.26 |       565.00
Класс            |            23.10 |           3.75 |       227.00
Громко плачу     |            24.70 |           1.35 |       654.00
Катаюсь от смеха |            25.60 |           0.77 |         0.00
Глаза-сердца     |            64.60 |          11.20 |       834.00
Целую            |            87.50 |           5.13 |       432.00
Сердце           |           118.00 |          26.00 |      1080.00
Слёзы радости    |           233.00 |           7.31 |      2270.00
Python не считает наш список из списков таблицей. Он видит только перечень строк. Столбцов в этой таблице для Python не существует. Чтобы отсортировать таблицу по столбцу с индексом 1, нам нужно пояснить: считай, что последовательность для сортировки состоит из элементов каждой строки с индексом 1, и по этой последовательности сортируй. Это объяснение делается лямбда-функцией — короткой безымянной функцией:
lambda row: row[1]
Эта функция принимает на вход очередную строку row и возвращает столбец из элементов каждой строки с индексом 1. В нашем случае это записывается row[1]. Название row для очередных строк мы выбрали сами для наглядности, можете придумать и другое. Создавать полноценные собственные функции вы научитесь в следующей теме, а пока для сортировки годится простенькая лямбда-функция.
Именованные аргументы можно комбинировать. Например, давайте отсортируем данные столбца «EmojiXpress, млн» по убыванию, применяя одновременно key и reverse:
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

data.sort(key=lambda row: row[1], reverse=True)

print('Название эмодзи  | EmojiXpress, млн |', end='')
print(' Instagram, млн | Твиттер, млн')
print('-------------------------------------', end='')
print('------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))
Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн
-------------------------------------------------------------------
Слёзы радости    |           233.00 |           7.31 |      2270.00
Сердце           |           118.00 |          26.00 |      1080.00
Целую            |            87.50 |           5.13 |       432.00
Глаза-сердца     |            64.60 |          11.20 |       834.00
Катаюсь от смеха |            25.60 |           0.77 |         0.00
Громко плачу     |            24.70 |           1.35 |       654.00
Класс            |            23.10 |           3.75 |       227.00
Счастлив         |            22.70 |           4.26 |       565.00
След от поцелуя  |            21.70 |           2.87 |        98.70
Сияю от радости  |            19.10 |           1.69 |       150.00
Подмигиваю       |            15.20 |           2.36 |       264.00
Два сердца       |            10.00 |           5.69 |       445.00
Задумчивость     |             6.81 |           0.64 |         0.00
Равнодушие       |             6.00 |           0.24 |       478.00
Солнечные очки   |             4.72 |           3.93 |       198.00
Огонь            |             4.50 |           2.49 |       150.00
Червы            |             3.31 |           1.82 |       697.00
Ухмыляюсь        |             2.26 |           1.02 |        87.30
Пожимаю плечами  |             1.74 |           0.11 |         0.00
Переработка      |             0.03 |           0.06 |       932.00
Можем видеть, какие эмодзи наиболее популярны в EmojiXpress. Теперь проделаем то же самое для остальных платформ.

# 5.1 - Сортировка по столбцу

Напомним, что Python хранит таблицу как список списков. Если нужно отсортировать её по определённому столбцу, его указывают именованным аргументом key. Переставим строки таблицы так, чтобы элементы столбца «EmojiXpress, млн» расположились в порядке возрастания:
 data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

data.sort(key=lambda row: row[1])

print('Название эмодзи  | EmojiXpress, млн |', end='')
print(' Instagram, млн | Твиттер, млн')
print('-------------------------------------', end='')
print('------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))
Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн
-------------------------------------------------------------------
Переработка      |             0.03 |           0.06 |       932.00
Пожимаю плечами  |             1.74 |           0.11 |         0.00
Ухмыляюсь        |             2.26 |           1.02 |        87.30
Червы            |             3.31 |           1.82 |       697.00
Огонь            |             4.50 |           2.49 |       150.00
Солнечные очки   |             4.72 |           3.93 |       198.00
Равнодушие       |             6.00 |           0.24 |       478.00
Задумчивость     |             6.81 |           0.64 |         0.00
Два сердца       |            10.00 |           5.69 |       445.00
Подмигиваю       |            15.20 |           2.36 |       264.00
Сияю от радости  |            19.10 |           1.69 |       150.00
След от поцелуя  |            21.70 |           2.87 |        98.70
Счастлив         |            22.70 |           4.26 |       565.00
Класс            |            23.10 |           3.75 |       227.00
Громко плачу     |            24.70 |           1.35 |       654.00
Катаюсь от смеха |            25.60 |           0.77 |         0.00
Глаза-сердца     |            64.60 |          11.20 |       834.00
Целую            |            87.50 |           5.13 |       432.00
Сердце           |           118.00 |          26.00 |      1080.00
Слёзы радости    |           233.00 |           7.31 |      2270.00
Python не считает наш список из списков таблицей. Он видит только перечень строк. Столбцов в этой таблице для Python не существует. Чтобы отсортировать таблицу по столбцу с индексом 1, нам нужно пояснить: считай, что последовательность для сортировки состоит из элементов каждой строки с индексом 1, и по этой последовательности сортируй. Это объяснение делается лямбда-функцией — короткой безымянной функцией:
lambda row: row[1]
Эта функция принимает на вход очередную строку row и возвращает столбец из элементов каждой строки с индексом 1. В нашем случае это записывается row[1]. Название row для очередных строк мы выбрали сами для наглядности, можете придумать и другое. Создавать полноценные собственные функции вы научитесь в следующей теме, а пока для сортировки годится простенькая лямбда-функция.
Именованные аргументы можно комбинировать. Например, давайте отсортируем данные столбца «EmojiXpress, млн» по убыванию, применяя одновременно key и reverse:
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

data.sort(key=lambda row: row[1], reverse=True)

print('Название эмодзи  | EmojiXpress, млн |', end='')
print(' Instagram, млн | Твиттер, млн')
print('-------------------------------------', end='')
print('------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))
Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн
-------------------------------------------------------------------
Слёзы радости    |           233.00 |           7.31 |      2270.00
Сердце           |           118.00 |          26.00 |      1080.00
Целую            |            87.50 |           5.13 |       432.00
Глаза-сердца     |            64.60 |          11.20 |       834.00
Катаюсь от смеха |            25.60 |           0.77 |         0.00
Громко плачу     |            24.70 |           1.35 |       654.00
Класс            |            23.10 |           3.75 |       227.00
Счастлив         |            22.70 |           4.26 |       565.00
След от поцелуя  |            21.70 |           2.87 |        98.70
Сияю от радости  |            19.10 |           1.69 |       150.00
Подмигиваю       |            15.20 |           2.36 |       264.00
Два сердца       |            10.00 |           5.69 |       445.00
Задумчивость     |             6.81 |           0.64 |         0.00
Равнодушие       |             6.00 |           0.24 |       478.00
Солнечные очки   |             4.72 |           3.93 |       198.00
Огонь            |             4.50 |           2.49 |       150.00
Червы            |             3.31 |           1.82 |       697.00
Ухмыляюсь        |             2.26 |           1.02 |        87.30
Пожимаю плечами  |             1.74 |           0.11 |         0.00
Переработка      |             0.03 |           0.06 |       932.00
Можем видеть, какие эмодзи наиболее популярны в EmojiXpress. Теперь проделаем то же самое для остальных платформ.

ЗАДАЧА

# Отсортируйте таблицу по столбцу «Instagram, млн» по убыванию и выведите её в наглядном формате (см. прекод)
# Обратите внимание, какие эмодзи наиболее популярны на этой платформе

# SOLUTION

data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

# < напишите код здесь >
data.sort(key=lambda row: row[2], reverse=True)

print('Название эмодзи  | EmojiXpress, млн |', end='')
print(' Instagram, млн | Твиттер, млн')
print('-------------------------------------', end='')
print('------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))

########################################################################################################################

# 5.2 - Сортировка по столбцу

# Отсортируйте таблицу по столбцу «Твиттер, млн» по убыванию и выведите её в наглядном формате (см. прекод)
# Обратите внимание, какие эмодзи наиболее популярны на этой платформе. Какой артефакт (необычный объект) выделяется
# особо?

# SOLUTION

data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

# < напишите код здесь >

data.sort(key=lambda row: row[3], reverse=True)

print('Название эмодзи  | EmojiXpress, млн |', end='')
print(' Instagram, млн | Твиттер, млн')
print('-------------------------------------', end='')
print('------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))

########################################################################################################################
6. Срезы
Тяжело держать в голове сразу много чисел. Поэтому после сортировки таблицы имеет смысл оставить только самые верхние строки — например, первые пять. Такие фрагменты списков называются срезы.
Они похожи на индексы, но используются для обращения не к отдельным элементам, а к их диапазонам. Для среза указывают начало и конец диапазона:
# англ. digit, "цифра", name, "название"
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[4:7])
['четыре', 'пять', 'шесть']
image
Первый индекс (в данном случае 4) будет включён в срез, а последний (в данном случае 7) — нет. Чтобы понять, почему разработчики Python так сделали, давайте представим плитку шоколада с нумерованными дольками. Срез 4:7 означает, что шоколадка ломается перед четвёртой долькой и перед седьмой.
Когда одна из границ диапазона совпадает с границей самого списка, эту границу можно вообще не указывать. Например, давайте напечатаем на экране первые несколько элементов двумя способами — с указанием начала списка (ноль) и без него.
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[0:5])
['ноль', 'один', 'два', 'три', 'четыре']
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[:5])
['ноль', 'один', 'два', 'три', 'четыре']
Так же можно поступать и с концом списка. Давайте, например, выведем три последних элемента (тоже двумя способами):
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[7:10])
['семь', 'восемь', 'девять']
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[7:])
['семь', 'восемь', 'девять']
Теперь сделаем срез, чтобы вывести первую пятёрку нашей таблицы:
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]
    
print('Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн')
print('-------------------------------------------------------------------')
for row in data[:5]:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))
Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн
-------------------------------------------------------------------
Ухмыляюсь        |             2.26 |           1.02 |        87.30
Сияю от радости  |            19.10 |           1.69 |       150.00
Катаюсь от смеха |            25.60 |           0.77 |         0.00
Слёзы радости    |           233.00 |           7.31 |      2270.00
Подмигиваю       |            15.20 |           2.36 |       264.00

# 6.1 - Срезы

Тяжело держать в голове сразу много чисел. Поэтому после сортировки таблицы имеет смысл оставить только самые верхние строки — например, первые пять. Такие фрагменты списков называются срезы.
Они похожи на индексы, но используются для обращения не к отдельным элементам, а к их диапазонам. Для среза указывают начало и конец диапазона:
# англ. digit, "цифра", name, "название"
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[4:7])
['четыре', 'пять', 'шесть']
image
Первый индекс (в данном случае 4) будет включён в срез, а последний (в данном случае 7) — нет. Чтобы понять, почему разработчики Python так сделали, давайте представим плитку шоколада с нумерованными дольками. Срез 4:7 означает, что шоколадка ломается перед четвёртой долькой и перед седьмой.
Когда одна из границ диапазона совпадает с границей самого списка, эту границу можно вообще не указывать. Например, давайте напечатаем на экране первые несколько элементов двумя способами — с указанием начала списка (ноль) и без него.
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[0:5])
['ноль', 'один', 'два', 'три', 'четыре']
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[:5])
['ноль', 'один', 'два', 'три', 'четыре']
Так же можно поступать и с концом списка. Давайте, например, выведем три последних элемента (тоже двумя способами):
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[7:10])
['семь', 'восемь', 'девять']
digits_names = [
    'ноль',
    'один',
    'два',
    'три',
    'четыре',
    'пять',
    'шесть',
    'семь',
    'восемь',
    'девять'
]

print(digits_names[7:])
['семь', 'восемь', 'девять']
Теперь сделаем срез, чтобы вывести первую пятёрку нашей таблицы:
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]
    
print('Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн')
print('-------------------------------------------------------------------')
for row in data[:5]:
    print('{: <16} | {: >16.2f} | {: >14.2f} | {: >12.2f}'.format(
        row[0], row[1], row[2], row[3]))
Название эмодзи  | EmojiXpress, млн | Instagram, млн | Твиттер, млн
-------------------------------------------------------------------
Ухмыляюсь        |             2.26 |           1.02 |        87.30
Сияю от радости  |            19.10 |           1.69 |       150.00
Катаюсь от смеха |            25.60 |           0.77 |         0.00
Слёзы радости    |           233.00 |           7.31 |      2270.00
Подмигиваю       |            15.20 |           2.36 |       264.00

ЗАДАЧА

# Сделайте срез, чтобы получить из списка следующие значения: «Глаза-сердца», «Целую», «Задумчивость»

# SOLUTION
emoji_names = [
    'Ухмыляюсь',
    'Сияю от радости',
    'Катаюсь от смеха',
    'Слёзы радости',
    'Подмигиваю',
    'Счастлив',
    'Глаза-сердца',
    'Целую',
    'Задумчивость',
    'Равнодушие'
]

# < напишите код здесь >

print(emoji_names[6:9])

########################################################################################################################

# 6.2 - Срезы

# Обновите код, чтобы в каждом из трёх случаев выводилась не вся таблица, а только её первые пять строк

# SOLUTION

data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

data.sort(key=lambda row: row[1], reverse=True)

# мы оставили только тот столбец, по которому сортировали
print('Название эмодзи  | Emojixpress, млн')
print('-----------------------------------')
for row in data[:5]:
    print('{: <16} | {: >16.2f}'.format(row[0], row[1]))
print()
print()

data.sort(key=lambda row: row[2], reverse=True)

# мы оставили только тот столбец, по которому сортировали
print('Название эмодзи  | Instagram, млн')
print('---------------------------------')
for row in data[:5]:
    print('{: <16} | {: >14.2f}'.format(row[0], row[2]))
print()
print()

data.sort(key=lambda row: row[3], reverse=True)

# мы оставили только тот столбец, по которому сортировали
print('Название эмодзи  | Твиттер, млн')
print('-------------------------------')
for row in data[:5]:
    print('{: <16} | {: >12.2f}'.format(row[0], row[3]))
print()
print()

########################################################################################################################
7. Анализ результатов
В Твиттере на третьем месте — эмодзи «Переработка». Мы уже говорили, что это артефакт в наших данных:
Название эмодзи  | Emojixpress, млн
-----------------------------------
Слёзы радости    |           233.00
Сердце           |           118.00
Целую            |            87.50
Глаза-сердца     |            64.60
Катаюсь от смеха |            25.60


Название эмодзи  | Instagram, млн
---------------------------------
Сердце           |          26.00
Глаза-сердца     |          11.20
Слёзы радости    |           7.31
Два сердца       |           5.69
Целую            |           5.13


Название эмодзи  | Твиттер, млн
-------------------------------
Слёзы радости    |      2270.00
Сердце           |      1080.00
Переработка      |       932.00
Глаза-сердца     |       834.00
Червы            |       697.00
Сортировать по данным одного только Твиттера нельзя — в данные попал артефакт. Значит и по другим сортировать рискованно: вдруг там тоже есть скрытые проблемы?
Нужен более надёжный критерий популярности эмодзи. Мы такой критерий выработаем, рассчитаем его для каждого эмодзи, а потом проведём по нему сортировку. Нам потребуется пристраивать к таблице ещё один столбец. Значит, пора научиться менять таблицу целиком — как список списков в цикле.

7. Анализ результатов
В Твиттере на третьем месте — эмодзи «Переработка». Мы уже говорили, что это артефакт в наших данных:
Название эмодзи  | Emojixpress, млн
-----------------------------------
Слёзы радости    |           233.00
Сердце           |           118.00
Целую            |            87.50
Глаза-сердца     |            64.60
Катаюсь от смеха |            25.60


Название эмодзи  | Instagram, млн
---------------------------------
Сердце           |          26.00
Глаза-сердца     |          11.20
Слёзы радости    |           7.31
Два сердца       |           5.69
Целую            |           5.13


Название эмодзи  | Твиттер, млн
-------------------------------
Слёзы радости    |      2270.00
Сердце           |      1080.00
Переработка      |       932.00
Глаза-сердца     |       834.00
Червы            |       697.00
Сортировать по данным одного только Твиттера нельзя — в данные попал артефакт. Значит и по другим сортировать рискованно: вдруг там тоже есть скрытые проблемы?
Нужен более надёжный критерий популярности эмодзи. Мы такой критерий выработаем, рассчитаем его для каждого эмодзи, а потом проведём по нему сортировку. Нам потребуется пристраивать к таблице ещё один столбец. Значит, пора научиться менять таблицу целиком — как список списков в цикле.

########################################################################################################################

# 8 - Изменение списков в цикле

Цикл for в том виде, в каком вы его объявляли до сих пор, годится далеко не для всех задач. Перебор всех элементов списка беспомощен, когда нужно что-нибудь сделать с каждым элементом. Научимся изменять простые списки со значениями столбцов. Вспомните наш старый пример: перевод значений из миллионов в единицы.
Очевидный способ — поменять переменную цикла — не сработает:
emojixpress = [
        2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0,
        4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333
]

print('Список до изменения:')
print(emojixpress)
print()

for element in emojixpress:
    element = element * 1000000
    
print('Список после попытки изменения:')
print(emojixpress)
Список до изменения:
[2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0, 4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333]

Список после попытки изменения:
[2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0, 4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333]
Проблема — в самом устройстве цикла for. Он копирует элементы списка. Поэтому строка
element = float(element)
меняет переменную element, но не меняет элемент списка.
Вместо того, чтобы перебирать непосредственно элементы списка, можно перебирать их индексы — то есть просто числа от нуля до длины списка (не включая саму длину). Это делают вызовом функции range(). Ей передаётся какой-нибудь аргумент, например, 5, и она перебирает все числа от 0 до своего аргумента (не включая его): 0, 1, 2, 3, 4. Поместив результат в цикл for, можно распечатать эти числа:
for element in range(5):
    print(element)
0
1
2
3
4
К сожалению, просто посмотреть результат выполнения функции range() не удастся:
range(5)
range(0, 5)
Дело в том, что Python не хранит все числа от 0 до 5, а просто запоминает, от какого и до какого числа создаётся последовательность. Это особенно полезно для вызовов функции вроде range(1000000000).
Опробуем новый принцип перебора элементов списка. У каждого элемента списка есть свой индекс. Чтобы пройтись по всем индексам списка emojixpress, используя функцию range(), передадим ей аргумент len(emojixpress):
emojixpress = [
    2.26, 19.1, 25.6, 233, 15.2, 22.7, 64.6, 87.5, 6.81, 6,
    4.72, 24.7, 21.7, 10, 118, 3.31, 23.1, 1.74, 4.5, 0.0333
]

for i in range(len(emojixpress)):
    print(emojixpress[i])
2.26
19.1
25.6
233
15.2
22.7
64.6
87.5
6.81
6
4.72
24.7
21.7
10
118
3.31
23.1
1.74
4.5
0.0333
Можно поменять каждый элемент списка по очереди:
emojixpress = [
        2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0,
        4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333
]

print('Список до изменения:')
print(emojixpress)
print()

for i in range(len(emojixpress)):
    emojixpress[i] = emojixpress[i] * 1000000
    
print('Список после изменения:')
print(emojixpress)
Список до изменения:
[2.26, 19.1, 25.6, 233.0, 15.2, 22.7, 64.6, 87.5, 6.81, 6.0, 4.72, 24.7, 21.7, 10.0, 118.0, 3.31, 23.1, 1.74, 4.5, 0.0333]

Список после изменения:
[2260000.0, 19100000.0, 25600000.0, 233000000.0, 15200000.0, 22700000.0, 64599999.99999999, 87500000.0, 6810000.0, 6000000.0, 4720000.0, 24700000.0, 21700000.0, 10000000.0, 118000000.0, 3310000.0, 23100000.0, 1740000.0, 4500000.0, 33300.0]

ЗАДАЧА

Некоторые ячейки в столбце с данными Твиттера принимают нулевые значения. Это связано с тем, что эмодзи редко используются и в источнике отсутствует информация о них. Нулевые значения не всегда удобны на практике — например, на них нельзя делить. Так как настоящие значения неизвестны, можно прибавить ко всем очень маленькую величину. Это исправит проблему, а значения для остальных ячеек сильно не испортятся.
Измените значения списка twitter: прибавьте к каждому элементу 0.001. Напечатайте на экране результат.

# SOLUTION

twitter = [
		87.3, 150, 0.0, 2270.0, 264.0, 565.0, 834.0, 432.0, 0.0, 478.0,
		198.0, 654.0, 98.7, 445.0, 1080.0, 697.0, 227.0, 0.0, 150.0, 932.0
]

for item in range(len(twitter)):
    twitter[item] = twitter[item]+0.001
	    
print(twitter)

########################################################################################################################
9. Новые столбцы (добавление элементов в список)
Теперь перейдём к добавлению в таблицу новых столбцов.
Мы уже научились изменять элементы списка, теперь нужно в каждый список-строку добавить новый элемент (соответствующий ячейке нового столбца). Для этого мы используем метод списка append(), добавляющий новый элемент в список. Разберём его сначала на простом примере:
emoji = [
    'Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 'Слёзы радости' 
]


print(emoji)

emoji.append('Подмигиваю')

print(emoji)
['Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 'Слёзы радости']
['Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 'Слёзы радости', 'Подмигиваю']
Метод append() добавляет свой аргумент в список как последний элемент.
Вызывая метод append() в цикле, можно добавить новый столбец. Попробуем для нашей таблицы: посчитаем долю использований каждого эмодзи из столбца «EmojiXpress, млн».
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

emojixpress_total = 1720

for i in range(len(data)):
    # Для обращения к столбцу с индексом 1 в строке с индексом i
    # используется двойное обращение по индексу: data[i][1]
    # data[i] - строка с индексом i
    # data[i][1] - её ячейка с индексом 1
    part = data[i][1] / emojixpress_total
    data[i].append(part)
    
    
print('Название эмодзи  | EmojiXpress, млн | EmojiXpress, доля')
print('-------------------------------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >17.1%}'.format(row[0], row[1], row[4]))
Название эмодзи  | EmojiXpress, млн | EmojiXpress, доля
-------------------------------------------------------
Ухмыляюсь        |             2.26 |              0.1%
Сияю от радости  |            19.10 |              1.1%
Катаюсь от смеха |            25.60 |              1.5%
Слёзы радости    |           233.00 |             13.5%
Подмигиваю       |            15.20 |              0.9%
Счастлив         |            22.70 |              1.3%
Глаза-сердца     |            64.60 |              3.8%
Целую            |            87.50 |              5.1%
Задумчивость     |             6.81 |              0.4%
Равнодушие       |             6.00 |              0.3%
Солнечные очки   |             4.72 |              0.3%
Громко плачу     |            24.70 |              1.4%
След от поцелуя  |            21.70 |              1.3%
Два сердца       |            10.00 |              0.6%
Сердце           |           118.00 |              6.9%
Червы            |             3.31 |              0.2%
Класс            |            23.10 |              1.3%
Пожимаю плечами  |             1.74 |              0.1%
Огонь            |             4.50 |              0.3%
Переработка      |             0.03 |              0.0%

# 9. Новые столбцы (добавление элементов в список)
Теперь перейдём к добавлению в таблицу новых столбцов.
Мы уже научились изменять элементы списка, теперь нужно в каждый список-строку добавить новый элемент (соответствующий ячейке нового столбца). Для этого мы используем метод списка append(), добавляющий новый элемент в список. Разберём его сначала на простом примере:
emoji = [
    'Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 'Слёзы радости' 
]


print(emoji)

emoji.append('Подмигиваю')

print(emoji)
['Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 'Слёзы радости']
['Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 'Слёзы радости', 'Подмигиваю']
Метод append() добавляет свой аргумент в список как последний элемент.
Вызывая метод append() в цикле, можно добавить новый столбец. Попробуем для нашей таблицы: посчитаем долю использований каждого эмодзи из столбца «EmojiXpress, млн».
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

emojixpress_total = 1720

for i in range(len(data)):
    # Для обращения к столбцу с индексом 1 в строке с индексом i
    # используется двойное обращение по индексу: data[i][1]
    # data[i] - строка с индексом i
    # data[i][1] - её ячейка с индексом 1
    part = data[i][1] / emojixpress_total
    data[i].append(part)
    
    
print('Название эмодзи  | EmojiXpress, млн | EmojiXpress, доля')
print('-------------------------------------------------------')
for row in data:
    print('{: <16} | {: >16.2f} | {: >17.1%}'.format(row[0], row[1], row[4]))
Название эмодзи  | EmojiXpress, млн | EmojiXpress, доля
-------------------------------------------------------
Ухмыляюсь        |             2.26 |              0.1%
Сияю от радости  |            19.10 |              1.1%
Катаюсь от смеха |            25.60 |              1.5%
Слёзы радости    |           233.00 |             13.5%
Подмигиваю       |            15.20 |              0.9%
Счастлив         |            22.70 |              1.3%
Глаза-сердца     |            64.60 |              3.8%
Целую            |            87.50 |              5.1%
Задумчивость     |             6.81 |              0.4%
Равнодушие       |             6.00 |              0.3%
Солнечные очки   |             4.72 |              0.3%
Громко плачу     |            24.70 |              1.4%
След от поцелуя  |            21.70 |              1.3%
Два сердца       |            10.00 |              0.6%
Сердце           |           118.00 |              6.9%
Червы            |             3.31 |              0.2%
Класс            |            23.10 |              1.3%
Пожимаю плечами  |             1.74 |              0.1%
Огонь            |             4.50 |              0.3%
Переработка      |             0.03 |              0.0%

ЗАДАЧА 1_2
Добавьте в список названий emoji ещё три следующих элемента, используя метод append(). Выведите результат на экран.

# SOLUTION

emoji = [
    'Ухмыляюсь', 'Сияю от радости', 'Катаюсь от смеха', 
    'Слёзы радости', 'Подмигиваю'
]

emoji.append('Счастлив')
emoji.append('Глаза-сердца')
emoji.append('Целую')

print(emoji)

ЗАДАЧА 2_2
Создайте в таблице новый столбец: суммарное количество использований на всех платформах. Отсортируйте таблицу по нему по убыванию и напечатайте на экране первые пять элементов. Вывод уже описан в коде:
Название эмодзи          | Суммарное использование, млн
-------------------------------------------------------
Слёзы радости            |                          ...
Сердце                   |                          ...
...
Проанализируйте статистику использования эмодзи по новой величине.

# SOLUTION
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

for i in range(len(data)):
    sum = data[i][1]+data[i][2]+data[i][3]
    data[i].append(sum)
data.sort(key=lambda row: row[4],reverse=True)
print('Название эмодзи  | Суммарное использование, млн')
print('-----------------------------------------------')
for row in data[:5]:
    print('{: <16} | {: >28.2f}'.format(row[0], row[4]))
########################################################################################################################
10. Нормирование
Название эмодзи  | Суммарное использование, млн
-----------------------------------------------
Слёзы радости    |                      2510.31
Сердце           |                      1224.00
Переработка      |                       932.09
Глаза-сердца     |                       909.80
Червы            |                       702.13
Результат улучшился несильно: «Переработка» по-прежнему в топе. Но в наших данных масштабы значений для разных платформ несопоставимы: в Твиттере значительно больше постов с эмодзи, чем на других платформах. Поэтому просто суммировать посты неправильно.
Представьте, что мы сравниваем, кто сильнее: человек, голубь или муравей? Человек массой 80 кг может нести 40-килограммовый мешок картошки, голубь весом 240 г — лететь с письмом массой 80 г, а муравей массой 2 мг — тащить лист массой до 100 мг. Так сравнивать трудно. А вот так гораздо лучше: человек несёт половину своей массы, голубь — треть, а муравей пятьдесят своих масс.
Мы применили нормирование — поделили массу каждого груза на соответствующий масштаб. То же самое нужно проделать и с нашими данными. Здесь масштаб оценивается средним значением по столбцу.
Рассчитаем новую величину для анализа популярности эмодзи:
для каждого столбца оценивается его масштаб (как среднее значение);
каждое значение в столбце нормируется (делится на масштаб);
нормированные значения складываются.
Назовём эту сумму «индекс использования».

10. Нормирование
Название эмодзи  | Суммарное использование, млн
-----------------------------------------------
Слёзы радости    |                      2510.31
Сердце           |                      1224.00
Переработка      |                       932.09
Глаза-сердца     |                       909.80
Червы            |                       702.13
Результат улучшился несильно: «Переработка» по-прежнему в топе. Но в наших данных масштабы значений для разных платформ несопоставимы: в Твиттере значительно больше постов с эмодзи, чем на других платформах. Поэтому просто суммировать посты неправильно.
Представьте, что мы сравниваем, кто сильнее: человек, голубь или муравей? Человек массой 80 кг может нести 40-килограммовый мешок картошки, голубь весом 240 г — лететь с письмом массой 80 г, а муравей массой 2 мг — тащить лист массой до 100 мг. Так сравнивать трудно. А вот так гораздо лучше: человек несёт половину своей массы, голубь — треть, а муравей пятьдесят своих масс.
Мы применили нормирование — поделили массу каждого груза на соответствующий масштаб. То же самое нужно проделать и с нашими данными. Здесь масштаб оценивается средним значением по столбцу.
Рассчитаем новую величину для анализа популярности эмодзи:
для каждого столбца оценивается его масштаб (как среднее значение);
каждое значение в столбце нормируется (делится на масштаб);
нормированные значения складываются.
Назовём эту сумму «индекс использования».

#ЗАДАЧА 1_3

Посчитайте средние значения для всех трёх платформ и сохраните их в переменных emojixpress_mean, instagram_mean и twitter_mean соответственно (напомним: англ. mean, здесь в значении «средний»). Напечатайте их значения на экране (см. код).

#SOLUTION
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]
emojixpress_sum = 0
instagram_sum = 0
twitter_sum = 0
for row in data:
    emojixpress_sum += row[1]
    instagram_sum += row[2]
    twitter_sum += row[3]
    
emojixpress_mean = emojixpress_sum / len(data)
instagram_mean = instagram_sum / len(data)
twitter_mean = twitter_sum / len(data)

print('Среднее для EmojiXpress: {:.2f}'.format(emojixpress_mean))
print('Среднее для Instagram: {:.2f}'.format(instagram_mean))
print('Среднее для Твиттера: {:.2f}'.format(twitter_mean))

#ЗАДАЧА 2_3
Вычислите «индекс использования» для каждого эмодзи. Получившийся столбец с этими индексами добавьте к таблице.
(Мы уже написали код для вывода на экран, пока без сортировки).

#SOLUTION
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

emojixpress_sum = 0
instagram_sum = 0
twitter_sum = 0
for row in data:
    emojixpress_sum += row[1]
    instagram_sum += row[2]
    twitter_sum += row[3]
    
emojixpress_mean = emojixpress_sum / len(data)
instagram_mean = instagram_sum / len(data)
twitter_mean = twitter_sum / len(data)

for i in range(len(data)):
    # Названия переменных выбраны, чтобы лучше отражать
    # их смысл. Normalized – от англ. "нормированный".
    emojixpress_normalized = data[i][1] / emojixpress_mean
    instagram_normalized = data[i][2] / instagram_mean
    twitter_normalized = data[i][3] / twitter_mean
    index = emojixpress_normalized + instagram_normalized + twitter_normalized
    data[i].append(index)

print('Название эмодзи  | Индекс использования')
print('---------------------------------------')
for row in data:
    print('{: <16} | {: >20.2f}'.format(row[0], row[4]))
    
#ЗАДАЧА 3_3
Финальный шаг для получения отчёта: отсортируйте таблицу по новому столбцу и напечатайте на экране только первые пять элементов.
Мы добавили в код вывод первых пяти элементов для трёх исходных столбцов.
Вывод должен выглядеть так:
Название эмодзи  | Emojixpress, млн
-----------------------------------
...


Название эмодзи  | Instagram, млн
---------------------------------
...


Название эмодзи  | Твиттер, млн
-------------------------------
...


Название эмодзи  | Индекс использования
---------------------------------------
...
Уточнения:
Названия выравнивайте по левому краю, а числа — по правому.
Числа выводите с точностью до двух знаков после запятой.
Между таблицами ставьте два переноса строки для наглядности.

#SOLUTION
data = [
    ['Ухмыляюсь', 2.26, 1.02, 87.3],
    ['Сияю от радости', 19.1, 1.69, 150.0],
    ['Катаюсь от смеха', 25.6, 0.774, 0.0],
    ['Слёзы радости', 233.0, 7.31, 2270.0],
    ['Подмигиваю', 15.2, 2.36, 264.0],
    ['Счастлив', 22.7, 4.26, 565.0],
    ['Глаза-сердца', 64.6, 11.2, 834.0],
    ['Целую', 87.5, 5.13, 432.0],
    ['Задумчивость', 6.81, 0.636, 0.0],
    ['Равнодушие', 6.0, 0.236, 478.0],
    ['Солнечные очки', 4.72, 3.93, 198.0],
    ['Громко плачу', 24.7, 1.35, 654.0],
    ['След от поцелуя', 21.7, 2.87, 98.7],
    ['Два сердца', 10.0, 5.69, 445.0],
    ['Сердце', 118.0, 26.0, 1080.0],
    ['Червы', 3.31, 1.82, 697.0],
    ['Класс', 23.1, 3.75, 227.0],
    ['Пожимаю плечами', 1.74, 0.11, 0.0],
    ['Огонь', 4.5, 2.49, 150.0],
    ['Переработка', 0.0333, 0.056, 932.0]
]

emojixpress_sum = 0
instagram_sum = 0
twitter_sum = 0
for row in data:
    emojixpress_sum += row[1]
    instagram_sum += row[2]
    twitter_sum += row[3]
    
emojixpress_mean = emojixpress_sum / len(data)
instagram_mean = instagram_sum / len(data)
twitter_mean = twitter_sum / len(data)

for i in range(len(data)):
    emojixpress_normalized = data[i][1] / emojixpress_mean
    instagram_normalized = data[i][2] / instagram_mean
    twitter_normalized = data[i][3] / twitter_mean
    index = emojixpress_normalized + instagram_normalized + twitter_normalized
    data[i].append(index)

data.sort(key=lambda row: row[1], reverse=True)

print('Название эмодзи  | Emojixpress, млн')
print('-----------------------------------')
for row in data[:5]:
    print('{: <16} | {: >16.2f}'.format(row[0], row[1]))
print()
print()

data.sort(key=lambda row: row[2], reverse=True)

print('Название эмодзи  | Instagram, млн')
print('---------------------------------')
for row in data[:5]:
    print('{: <16} | {: >14.2f}'.format(row[0], row[2]))
print()
print()

data.sort(key=lambda row: row[3], reverse=True)

print('Название эмодзи  | Твиттер, млн')
print('-------------------------------')
for row in data[:5]:
    print('{: <16} | {: >12.2f}'.format(row[0], row[3]))
print()
print()

data.sort(key=lambda row: row[4],reverse=True)

print('Название эмодзи  | Индекс использования')
print('---------------------------------------')
for row in data[:5]:
    print('{: <16} | {: >20.2f}'.format(row[0], row[4]))
print()
########################################################################################################################

11. Заключение
Выводы из данных
Название эмодзи  | Emojixpress, млн
-----------------------------------
Слёзы радости    |           233.00
Сердце           |           118.00
Целую            |            87.50
Глаза-сердца     |            64.60
Катаюсь от смеха |            25.60


Название эмодзи  | Instagram, млн
---------------------------------
Сердце           |          26.00
Глаза-сердца     |          11.20
Слёзы радости    |           7.31
Два сердца       |           5.69
Целую            |           5.13


Название эмодзи  | Твиттер, млн
-------------------------------
Слёзы радости    |      2270.00
Сердце           |      1080.00
Переработка      |       932.00
Глаза-сердца     |       834.00
Червы            |       697.00


Название эмодзи  | Индекс использования
---------------------------------------
Слёзы радости    |                13.23
Сердце           |                11.95
Глаза-сердца     |                 6.31
Целую            |                 4.66
Счастлив         |                 2.87
Какие выводы можно сделать из нашего исследования?
Самые популярные эмодзи связаны с положительными эмоциями — весельем и любовью.
На разных платформах порядок и выбор эмодзи немного отличается, но самые популярные эмодзи везде похожи.
Отдельные ресурсы имеют свои особенности, которые генерируют статистические выбросы, как в случае с символом переработки в Твиттере. От артефактов можно избавиться сбором значений со всех платформ и нормированием.
Что дальше
Первое исследование закончилось так успешно, что его результат можно смело показывать профессионалам. Вот вы подтвердили гипотезу статистикой. Научились превращать списки в таблицы и сортировать значения, находить среди них выдающиеся. Скажете, так может безо всякого языка Python любая программа работы с таблицами в стандартном офисном пакете? Да, но владеть языком программирования хорошо потому, что вы сможете сделать думающую таблицу, где сами напишете функции под свои собственные задачи. Такие, которых ни у кого нет. Да ещё способные принимать решения в зависимости от величины значений. В следующей теме мы научимся ставить программе условия и делать собственные «программы в программе» — функции. Вперёд! Вы на пороге настоящего программирования.
Забери с собой
Чтобы ничего не забыть, скачайте шпаргалку
